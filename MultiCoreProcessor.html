<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=500px, initial-scale=3.0">
  <title>BasantKhalil</title>

  <!--
    - favicon
  -->
  <link rel="shortcut icon" href="./assets/images/logo.ico" type="image/x-icon">

  <!--
    - custom css link
  -->
  <link rel="stylesheet" href="./assets/css/style.css">

  <!--
    - google font link
  -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600&display=swap" rel="stylesheet">
</head>

<body>

  <!--
    - #MAIN
  -->

  <main>

    <!--
      - #SIDEBAR
    -->

    <aside class="sidebar" data-sidebar>

      <div class="sidebar-info">

        <figure class="avatar-box">
          <img src="./assets/images/my-avatar.png" alt="Basant Khalil" width="80">
        </figure>

        <div class="info-content">
          <h1 class="name" title="Basant khalil">Basant Khalil</h1>
          <p class="title">
            <span style="color: #FFFC33;"><big>Software Engineer</big></span><span style="color: #33FFFC;">Electrical&amp;Computer Engineer</span></p>
        </div>

        <button class="info_more-btn" data-sidebar-btn>
          <span>Show Contacts</span>

          <ion-icon name="chevron-down"></ion-icon>
        </button>

      </div>

      <div class="sidebar-info_more">

        <div class="separator"></div>

        <ul class="contacts-list">

          <li class="contact-item">
            <div class="icon-box">
              <ion-icon name="mail-outline"></ion-icon>
            </div>

            <div class="contact-info">
              <p class="contact-title">Email</p>

              <a href="mailto:bak94@cornell.edu" class="contact-link">bak94@cornell.edu</a>
            </div>

          </li>

          <li class="contact-item">

            <div class="icon-box">
              <ion-icon name="phone-portrait-outline"></ion-icon>
            </div>

            <div class="contact-info">
              <p class="contact-title">Phone</p>

              <a href="tel:+6147178842" class="contact-link">+1 (614) 717-8842</a>
            </div>

          </li>
          
           <li class="contact-item">

            <div class="icon-box">
              <ion-icon name="logo-github"></ion-icon>
            </div>

            <div class="contact-info">
              <p class="contact-title">GitHub</p>

              <a href="https://github.com/Basant-khalil" class="contact-link">https://github.com/Basant-khalil</a>
            </div>

          </li>

          <li class="contact-item">

            <div class="icon-box">
              <ion-icon name="location-outline"></ion-icon>
            </div>

            <div class="contact-info">
              <p class="contact-title">Location</p>

              <address>Columbus, Ohio, USA</address>
            </div>

          </li>

        </ul>

        <div class="separator"></div>

        <ul class="social-list">

          <li class="social-item">
            <a href="https://github.com/Basant-khalil" class="social-link">
              <ion-icon name="logo-github"></ion-icon>
            </a>
          </li>

          <li class="social-item">
            <a href="https://www.linkedin.com/in/basantKhalil" class="social-link">
              <ion-icon name="logo-linkedIn"></ion-icon>
            </a>
          </li>

        </ul>

      </div>

    </aside>


<div class="main-content">

      <!--
        - #NAVBAR
      -->

      <nav class="navbar">

        <ul class="navbar-list">
	<li>
          <button class="navbar-link active" data-nav-link onclick="window.location.href='https://basant-khalil.github.io/Portfolio/'">Back</button>
        </li>

        </ul>

      </nav>


      <!-------------------------------------------------------------------- Article Text -------------------------------------------------------------------->
      <article class="about  active" data-page="MultiCoreProcessor">
        <header>
          <h2 class="h2 article-title">Single & Multi-Core Processors</h2>
        </header>
        <section class="about-text">
          <p>
		  The main goal of this project was to delve into various topics, including software/hardware co-design, programming single- and multithreaded C programs, 
		  and evaluating computer architecture based on architecture-level implementations. 
		  In this project, I tackled significant themes in computer architecture, including memory networks and incremental design. 
		  Furthermore, I explored software-hardware co-design to gain a deep understanding of implementing software applications, hardware/software interfaces, 
		  and hardware microarchitecture.
		  <br>  Multicore processors enable simultaneous handling of multiple threads, resulting in better performance for systems running multiple applications 
		  concurrently. By allocating different threads to separate cores, multicore processors exploit thread-level parallelism. 
		  Although not all applications can be fully parallelized, the performance benefits of multicore processors outweigh the associated costs, including 
		  hardware, area, and energy requirements. Despite the higher energy consumption of multicore processors due to running multiple threads and supporting 
		  additional hardware, the energy usage per thread is lower compared to a single-core processor.
		  Increasing the number of cores significantly improves system performance for concurrent multithreaded applications.
           <br>  <br> The project involved two designs: a <font color="gold"><strong>baseline design</strong></font> featuring a single-core processor with instruction and
		  data caches, and an <font color="gold"><strong>alternative design</strong></font> consisting of a multicore processor with private instruction caches 
		  and a shared, banked data cache.
       
		  <br> I conducted evaluations by developing both single-threaded and multithreaded sorting microbenchmarks in C and analyzed the compiled binary on both 
		  the baseline and alternative designs. 
		  The evaluation results demonstrated that the alternative design outperformed the baseline design in terms of CPI (cycles per instruction) for 
		  multithreaded programs. 
            For instance, the multithreaded design exhibited a CPI of <span style="color: gold; font-weight: bold; font-style: italic; display: inline;">1.85</span> for the 
		  multithreaded vvadd test, while the single-core design had a CPI of <span style="color: gold; font-weight: bold; font-style: italic; display: inline;">5.45</span> for 
		  the same test. Similar improvements were observed in other evaluation tests, indicating that the alternative design effectively exploited thread-level 
		  parallelism to enhance throughput and reduce CPI.
       	<center>
		<img src="assets/images/roster_fig1.png" id="frst" class="center"
            width="500" style="max-width:95%;border:3px solid #F1D16C;">
	</center>     
		  
	<div style="text-align: center;"><h3 class="h3 clients-title"> <font color="white"><strong>Baseline Design</strong></font></h3></div>
The baseline design depicted above in Figure 1 represents a single-core, pipelined processor with full bypassing. It consists of an instruction cache and an 
		unbanked data cache. The absence of networks in this design simplifies the flow of memory data through a single processor. 
The baseline design leverages the alternative design from a previous project to reduce stalling by implementing bypassing. Bypassing plays a crucial role in 
		enhancing processor throughput with minimal additional hardware, area, and power costs. 
Additionally, the instruction and data caches in the baseline design, adapted from the alternative design in a different project, utilize temporal locality 
		and are two-way associative, respectively.
<br>
In terms of software, I implemented a scalar quicksort algorithm to sort an array of integers in the baseline design. Quicksort selects a pivot element and 
		rearranges the array such that elements on the right are greater than the pivot, and elements on the left are smaller. 
The algorithm recursively applies quicksort to the divided portions until the entire array is sorted. Selecting the median value as the pivot ensures expected 
		<font color="gold"><strong>O(n log n)</strong></font> performance for the quicksort function. 
		This algorithm was chosen as a suitable baseline due to its spatial locality and efficient sorting capabilities compared to other algorithms like 
		merge sort.
	<div style="text-align: center;"><h3 class="h3 clients-title"> <font color="white"><strong>Alternative Design</strong></font></h3></div>
		
The alternative design, showcased in figure 7 below (and at a high level in figure 2 below), represents a quad-core processor with four instruction caches and a 
		banked data cache system. Networks play a vital role in managing the interface between caches, main memory, and processors. The multicore data cache 
		includes four data cache banks, a cachenet, and a memnet. 
	<div class="column" style="display: flex; align-items: center;">
  	<img src="assets/images/roster_fig7.png" id="rcimage1" 
   	 style="max-width:70%;border:3px solid #F1D16C; height: 350px; object-fit: contain;">
 	 <img src="assets/images/roster_fig2.png" id="rcimage2" 
   	 style="max-width:70%;border:3px solid #F1D16C; height: 350px; object-fit: contain;">
	</div>
<br> The cachenet shown in Figure 3 below handles the connectivity between the processors and the data cache banks, while the memnet is responsible for refilling the 
		instruction caches and data cache banks. 
	<center>
		<img src="assets/images/roster_fig3.png" id="frst" class="center"
            width="500" style="max-width:95%;border:3px solid #F1D16C;">
	</center>     
<br> This network has an upstream (the processor) and the downstream (main memory) message adapter that converts processor and main memory messages to network messages. 
	The upstream adapter extracts the bank bits in Figure 4 shown below from the
processor and includes them in the destination header. The Memnet in Figure 5 works similarly as the cachenet, but the upstream
adapter inserts a zero always in the destination field.
	<div class="column" style="display: flex; align-items: center;">
  	<img src="assets/images/roster_fig4.png" id="rcimage1" 
   	 style="max-width:50%;border:3px solid #F1D16C; height: 300px; object-fit: contain;">
 	 <img src="assets/images/roster_fig5.png" id="rcimage2" 
   	 style="max-width:50%;border:3px solid #F1D16C; height: 300px; object-fit: contain;">
	</div>
<br>  The memnet refills the instruction caches and data cache banks. Finally, the MCoreDataCache module in figure 6 connects the cachenet, the MemNet, and the four 
	cache banks to create the complete four bank
data cache system
	<center>
	<img src="assets/images/roster_fig6.png" id="frst" class="center"
            width="500" style="max-width:95%;border:3px solid #F1D16C;">
	</center>  
<br>The alternative design incorporates the processor design from a previous project, which includes bypassing and stalling to handle RAW data hazards more 
		efficiently. 
Moreover, the alternative design utilizes a two-way set associative cache for the instruction caches, offering a higher hit rate compared to the direct-mapped 
		cache in the baseline design.
<br> To provide a more realistic processor and cache design, I instantiated the MCoreDataCache module along with four processors, four instruction caches, and 
		MemNet for the instruction caches in the multicore system. The incremental approach I followed in this design demonstrates the principles of 
		modularity and hierarchy, as the components are organized into modules that interact to form the final MultiCore system.
<br> For the sorting algorithm in the alternative design, I implemented a mergesort algorithm. Mergesort combines two sorted arrays into one larger sorted array. 
		The algorithm divides the array into two halves, recursively applies quicksort on each half, and then merges the sorted halves. This 
		implementation of mergesort complements the alternative design, as it allows us to compare the advantages and disadvantages of dividing the 
		array among multiple cores.
<br> While multicore processors offer the advantage of running multiple threads concurrently, it is essential to consider the trade-offs when adding more cores. 
		Simply increasing the number of cores without proper consideration can lead to higher overhead in dividing the work to be done in parallel. It is 
		crucial to strike a balance and avoid excessive core counts. Nevertheless, the alternative design, with its exploitation of thread-level 
		parallelism, delivers superior performance compared to the single-core baseline design.

<div style="text-align: center;"><h3 class="h3 clients-title"> <font color="white"><strong>Testing Strategy</strong></font></h3></div>
	The single-core system, consisting of one processor along with instruction and data caches, was tested with a selection of assembly tests created during 
		previous project. One or two instructions were chosen from each category, such as add and mul from rr, addi from rimm, bne from branch, jal from 
		jump, lw and sw from memory, and csrr and csrw from csr type of instructions.
		<br> For the multicore design, individual design blocks like CacheNet, MemNet, and McoreDataCache were also tested. CacheNet was tested by 
		connecting test sources and test sinks to the upstream network and a <span style="color: gold; font-weight: bold; font-style: italic; display: inline;">4</span> -port test memory, 
		shown in Figure 3 above, to the downstream network. 
		Similarly, MemNet was tested by connecting test sources and test sinks to the upstream network and a single-port test memory to the downstream 
		network. 
		The McoreDataCache, which combines CacheNet, MemNet, and four cache banks, was unit tested by connecting test sources and test sinks to the 
		CacheNet and a single-port test memory to the MemNet.
		<br> The test sets used for CacheNet and McoreDataCache were implemented as well. To accommodate four sources and four sinks, the 
		TestNetCacheSink was used to allow out-of-order delivery and ignore the cache test bits. The MemNet tests reused the messages of TestMemory.
		<br> To fully test the multicore system, the same instructions as in the single-core system were used, with the exception of sw and csr 
		instructions. Some tests of the sw instruction might lead to data races when multiple cores try to access the same address, potentially 
		resulting in a core reading data that has already been overwritten. To test csr in the multicore system, a list of values was passed in the 
		syntax, which acted as source/sink messages for each core based on its ID.
		<br> To compare single and multi-threaded benchmarks, several algorithms, including binary search, complex number multiplication, 
		applying a masked filter to an image, addition of two vectors, and quicksort, were provided. All of these algorithms were first 
		verified for functionality on native <span style="color: gold; font-weight: bold; font-style: italic; display: inline;">x64</span> systems, 
		compiled for the <span style="color: gold; font-weight: bold; font-style: italic; display: inline;">TinyRV2</span> processor, and then ISA simulated using 
		Functional Level Verification. The object file was also targeted to the single and multicore systems created using simulators score-sim and mcore-sim. 
	<br>	The testing strategy followed an incremental approach, starting with basic tests, then directed tests, and finally random tests intended for 
		the test subsystem. Basic tests checked the system's functionality, directed tests stressed corner cases and negative scenarios, while random 
		tests were variations of basic and directed tests with random inputs. Different delays were added to the test source for thorough verification.
<div style="text-align: center;"><h3 class="h3 clients-title"> <font color="white"><strong>Evaluataion</strong></font></h3></div>
	The performance of different processors was analyzed using a variety of benchmark algorithms, including binary search, complex number multiplication, 
		applying a masked filter to an image, sorting a list, and performing addition between two vectors. Both single-threaded and multi-threaded 
		versions of each benchmark were used.
		<br> The single-threaded sort algorithm was implemented as a quicksort. The multi-threaded sort involved each of the four cores performing 
		quicksort on a quarter of the dataset and then merging the sorted portions together. The required number of cycles, CPI (Cycles Per Instruction), 
		and the number of committed instructions for each benchmark were recorded and analyzed.
		<br> In both figures below, it can be observed that while the multicore implementation improved the number of cycles required for the benchmark 
		cases, the improvement did not match the naive expectation of a <span style="color: gold; font-weight: bold; font-style: italic; display: inline;">4x</span> speed increase over the single-core implementation. 
	<div class="column" style="display: flex; align-items: center;">
  	<img src="assets/images/roster_fig8.png" id="rcimage1" 
   	 style="max-width:50%;border:3px solid #F1D16C; height: 350px; object-fit: contain;">
 	 <img src="assets/images/table1.png" id="rcimage2" 
   	 style="max-width:50%;border:3px solid #F1D16C; height: 350px; object-fit: contain;">
	</div>
		<br>Data dependencies between the different cores could lead to stalls in one or more cores, reducing the overall speedup. Additionally, there is 
		overhead involved in distributing the work between each core, as seen by the number of cycles for the single-threaded benchmarks on the single and 
		multicore processors in Table 1. The overhead can range from <span style="color: gold; font-weight: bold; font-style: italic; display: inline;">2.5%</span> additional cycles 
		for binary search to nearly <span style="color: gold; font-weight: bold; font-style: italic; display: inline;">20%</span> more cycles for complex 
		multiplication.
		<br>For the multi-threaded benchmarks, there was a <span style="color: gold; font-weight: bold; font-style: italic; display: inline;">1.8</span> to 
		<span style="color: gold; font-weight: bold; font-style: italic; display: inline;">2.75x</span> improvement over the single-core implementation. The largest speedup was observed 
		in cases where operations were independent, such as binary search, complex multiplication, and applying a filter. The benefit of the multicore 
		processor was smaller for adding two vectors together, as the number of operations was small enough that the overhead of creating new threads 
		started to play a significant role. The smallest improvement was seen in the sorting benchmark due to the additional operations required to merge 
		the sorted data.
		<br>The complexity of the program and the level of data dependency determine the performance of the multicore implementation. For shorter programs,
		the additional overhead of assigning operations to each core can reduce the performance benefit and even negate it for very short programs. 
		However, in general, the multicore processor is expected to perform better for longer programs with a higher degree of concurrency. It can 
		allocate different threads to different cores, enabling concurrent execution and increased throughput.
		<br>It's important to note that the multicore processor is more complex than the single-core design, requiring more transistors. It includes 
		three additional cores, six additional caches, and a network management system. As a result, a multicore system will be more expensive and 
		require more chip space and energy to power the additional cores and the network. The clock frequency of both systems will likely be comparable, 
		as the valid/ready interface between the cores, caches, and network removes these additional structures from the critical path. However, the 
		multicore system's clock might be slightly slower due to the increased distance between components.
		</p>
        
        </section>
      </article>
    </div>
  </main>

	
  <!--
    - custom js link
  -->
  <script src="./assets/js/script.js"></script>

  <!--
    - ionicon link
  -->
  <script type="module" src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js"></script>
  <script nomodule src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js"></script>

</body>

</html>
